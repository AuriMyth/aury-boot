---
alwaysApply: false
---
# AuriMyth Foundation Kit 开发规范

**核心原则：永远不要考虑向后兼容**

## 1. 架构层次与依赖规则

### 层次结构
```
application/     # 应用层（API、配置、编排）
domain/          # 领域层（业务逻辑、模型、接口）
infrastructure/  # 基础设施层（数据库、缓存、任务实现）
common/          # 基础层（异常、日志、i18n，无业务/HTTP依赖）
```

### 依赖规则
遵循单向依赖：`application` → `domain` → `infrastructure` → `common`

**允许的依赖 (✅)**
- `application` → 引用所有层
- `domain` → 引用 `infrastructure` 和 `common`
- `infrastructure` → 引用 `common`
- `common` → **不依赖任何层**（只依赖标准库/第三方基础库）

**禁止的反向依赖 (❌)**
- `common` ❌ 引用 `domain`, `infrastructure`, `application`
- `domain` ❌ 引用 `application`
- `infrastructure` ❌ 引用 `application`, `domain`
- `common` ❌ 引用 HTTP 框架 (FastAPI/Starlette)

### 跨层通信
- **配置传递**：`application` 层负责将应用配置转换为 `infrastructure` 层需要的参数。
- **接口抽象**：使用接口定义依赖。

---

## 2. 代码组织与职责

| 层级 | 职责 | 关键内容 | 禁止内容 |
| :--- | :--- | :--- | :--- |
| **Application** | 组装与接入 | API 接口, Config 适配, Middleware, FoundationApp | 核心业务逻辑 |
| **Domain** | 核心业务 | Models, Repository 接口, Service 基类, 领域事件 | 具体的基础设施实现 |
| **Infrastructure** | 外部实现 | Database, Cache, Tasks 等的具体实现 (Manager/Settings) | 应用层常量/配置 |
| **Common** | 通用工具 | FoundationError, Logging (纯日志), i18n | HTTP 依赖, 业务逻辑 |

---

## 3. 核心开发规范

### 常量定义
- **Application 层**：定义 `ComponentName`, `ServiceType` 等全局枚举。
- **Infrastructure 层**：组件定义**内部常量**，**严禁**依赖 Application 层常量。
- **命名**：类名 `PascalCase`，值 `UPPER_SNAKE_CASE`。

### 异常处理
- **继承体系**：所有异常继承 `FoundationError` (`common/exceptions`)。
- **分层定义**：各层定义自己的异常，Infrastructure 异常**直接继承** `FoundationError`。
- **命名**：以 `Error` 结尾 (如 `DatabaseError`)。

### 配置管理
- **Infrastructure**：每个组件有独立的 `settings.py` (使用 `pydantic-settings`)。
- **Application**：继承组件配置作为适配层，提供统一入口。
- **原则**：Infrastructure 组件**只使用自己的配置类**。

### HTTP 相关
- **位置**：所有 HTTP 中间件/装饰器必须在 `application/middleware/`。
- **隔离**：`common` 和 `domain` 层**严禁**包含 HTTP 框架依赖。

---

## 4. 约定大于配置

1.  **命名约定**：
    - 模块/包：`snake_case`
    - 类：`PascalCase` (`DatabaseManager`)
    - 自动发现：`infrastructure/*/manager.py` 自动注册为 `{Component}Manager`。
2.  **默认值约定**：
    - **必须**提供有意义的默认值 (如端口、超时)。
    - **关键配置** (如密码、URL) **强制**显式配置。
3.  **配置优先级**：参数 > 环境变量 > 配置文件 > 默认值。

---

## 5. 组件设计与代码复用

### Component 基类
所有功能单元继承 `Component`，通过 `setup(app, config)` 初始化，`application` 层在此处进行配置转换。

### 代码复用决策表

| 场景 | 推荐方案 | 关键原则 |
| :--- | :--- | :--- |
| **简单工具/字段** (如时间戳) | **Mixin** | 无状态，无隐式依赖，不含业务逻辑 |
| **有状态/复杂逻辑** (如服务) | **组合 (Composition)** | 显式依赖注入 (构造函数/Setter) |
| **易变业务规则** (如支付方式) | **策略模式 (Strategy)** | 接口定义，DI 注入，禁止内部 `new` |
| **简单算法/回调** | **函数式 (Lambda)** | 传递函数而非创建策略类 |
| **横切关注点** (如缓存/监控) | **装饰器 (Decorator)** | 包裹对象，不修改原始类代码 |

---

## 6. 编码细则

- **类型提示**：使用 Python 3.13+ 语法 (`list[str]`, `str | None`)；公共接口必须有类型提示。
- **导入规范**：标准库 → 第三方 → 本地 (Common→Domain→Infra→App)；引用置于文件顶部。
- **依赖选择**：优先先进且验证过的库 (如 `ruff`, `pydantic v2`, `sqlalchemy 2.0+`)，避免过时库 (Celery, RQ)。
- **向后兼容**：**禁止**。直接删除旧代码，不保留 `deprecated` 或兼容层。

---

## 7. 提交前检查清单

- [ ] **架构**：是否遵守 App → Domain → Infra → Common 的单向依赖？
- [ ] **Common**：是否不包含 HTTP 依赖和业务逻辑？
- [ ] **常量/配置**：Infra 层是否独立，未引用 App 层常量/配置？
- [ ] **规范**：是否使用 Python 3.13 类型提示？是否有文档字符串？
- [ ] **兼容性**：是否已删除所有过时代码（无向后兼容）？
- [ ] **设计**：复杂逻辑是否使用了组合/策略模式而非 Mixin？
