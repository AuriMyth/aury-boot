---
alwaysApply: true
---
# AuriMyth Foundation Kit 开发规范
永远不要考虑向后兼容
## 目录

- [架构层次](#架构层次)
- [依赖关系规则](#依赖关系规则)
- [代码组织规范](#代码组织规范)
- [常量定义规范](#常量定义规范)
- [异常处理规范](#异常处理规范)
- [配置管理规范](#配置管理规范)
- [约定大于配置规范](#约定大于配置规范)
- [组件设计规范](#组件设计规范)
- [代码复用与动态行为设计](#代码复用与动态行为设计)
- [依赖选择规范](#依赖选择规范)
- [命名规范](#命名规范)
- [导入规范](#导入规范)
- [类型提示规范](#类型提示规范)

---

## 架构层次

Foundation Kit 采用分层架构，从底层到顶层依次为：

```
common/          # 最基础层（只依赖标准库和第三方基础库）
  ├── exceptions/        # FoundationError（异常基类）
  ├── logging/           # 日志系统（纯日志功能，无 HTTP 依赖）
  └── i18n/              # 国际化（翻译、日期/数字本地化）

domain/          # 领域层（业务逻辑基础）
  ├── exceptions/        # CoreException, ModelError, VersionConflictError
  ├── models/            # ORM 模型基类
  ├── repository/        # 仓储模式（接口）
  ├── service/           # 服务模式
  ├── transaction/       # 事务管理
  └── events/            # 领域事件

infrastructure/  # 基础设施层（外部依赖实现）
  ├── database/          # 数据库管理
  ├── cache/            # 缓存管理
  ├── storage/          # 对象存储
  ├── tasks/            # 任务队列
  └── scheduler/        # 调度器

application/     # 应用层（API、配置、接口）
  ├── config/           # 配置管理
  ├── constants/        # 应用层常量（ServiceType, SchedulerMode）
  ├── middleware/       # HTTP 中间件
  ├── interfaces/       # API 接口定义
  └── app/              # FoundationApp
```

## 依赖关系规则

### 基本原则

```
application → domain → infrastructure → common
```

**规则**：
- ✅ `application` 可以引用所有层
- ✅ `domain` 可以引用 `infrastructure` 和 `common`
- ✅ `infrastructure` 可以引用 `common`
- ✅ `common` 不依赖任何层（最底层，只依赖标准库和第三方基础库）

### 禁止的反向依赖

- ❌ `common` 不能引用 `domain`、`infrastructure`、`application`
- ❌ `domain` 不能引用 `application`
- ❌ `infrastructure` 不能引用 `application`、`domain`

### 跨层通信

当需要跨层通信时，应该：
1. **配置传递**：通过参数传递，而不是直接导入
2. **适配层**：在 `application` 层创建适配层，将应用配置转换为基础设施层需要的参数
3. **接口抽象**：使用接口/抽象类定义依赖，而不是具体实现

**示例**：
```python
# ✅ 正确：application 层转换配置
class TaskComponent(Component):
    async def setup(self, app: FoundationApp, config: BaseConfig) -> None:
        # 将 application 层的 ServiceType 转换为 infrastructure 层的 TaskRunMode
        run_mode = TaskRunMode.WORKER if config.service.service_type == ServiceType.WORKER else TaskRunMode.PRODUCER
        await task_manager.initialize(run_mode=run_mode, ...)

# ❌ 错误：infrastructure 层直接使用 application 层常量
from aurimyth.foundation_kit.application.constants import ServiceType  # 反向依赖！
```

## 代码组织规范

### 1. Common 层

**职责**：最基础的工具层，不依赖任何业务逻辑

**允许的内容**：
- ✅ 异常基类（`FoundationError`）
- ✅ 日志系统（纯日志功能，无 HTTP 依赖）
- ✅ 国际化（i18n）
- ✅ 通用工具函数（只依赖标准库）

**禁止的内容**：
- ❌ HTTP 框架依赖（FastAPI、Starlette）
- ❌ 业务逻辑依赖
- ❌ 基础设施依赖

**文件组织**：
```
common/
  ├── exceptions/        # 异常基类
  ├── logging/           # 日志系统
  └── i18n/              # 国际化
```

### 2. Domain 层

**职责**：业务逻辑基础，领域模型和仓储

**允许的内容**：
- ✅ ORM 模型基类
- ✅ Repository 接口
- ✅ Service 基类
- ✅ 领域异常（继承 `FoundationError`）
- ✅ 事务管理工具
- ✅ 领域事件定义

**文件组织**：
```
domain/
  ├── __init__.py
  ├── exceptions/        # CoreException, ModelError, VersionConflictError
  ├── models/            # BaseModel, TimestampedModel, etc.
  ├── repository/        # IRepository（接口）
  ├── service/           # BaseService
  ├── transaction/       # 事务管理工具
  └── events/            # 领域事件定义
```

### 3. Infrastructure 层

**职责**：外部依赖的实现，每个组件独立管理

**组织原则**：
- 每个组件（database、cache、tasks 等）都有独立的目录
- 每个组件包含：`manager.py`、`exceptions.py`、`settings.py`、`constants.py`（如果需要）

**文件组织**：
```
infrastructure/
  ├── database/          # DatabaseManager, DatabaseSettings
  ├── cache/            # CacheManager
  ├── tasks/            # TaskManager, TaskSettings, constants.py
  └── ...
```

**重要原则**：
- ✅ 每个组件可以有**自己的内部常量**（如 `TaskRunMode`）
- ❌ 不能使用 `application` 层的常量（如 `ServiceType`）
- ✅ `application` 层负责将应用配置转换为组件需要的参数

### 4. Application 层

**职责**：应用配置、API 接口、组件编排

**文件组织**：
```
application/
  ├── constants/          # ComponentName, ServiceType, SchedulerMode
  ├── config/            # BaseConfig, DatabaseSettings
  ├── middleware/        # HTTP 中间件
  ├── errors/            # 错误处理
  ├── interfaces/        # API 接口定义（ingress, egress）
  └── app/               # FoundationApp, Component
```

## 常量定义规范

### 常量定义规范

**应用层常量**（`application/constants/`）：
- `ComponentName` - 组件名称枚举
- `ServiceType` - 服务类型（API、WORKER、SCHEDULER）
- `SchedulerMode` - 调度器模式（EMBEDDED、STANDALONE、DISABLED）

**Infrastructure 层内部常量**：
- ✅ 每个组件可以有**自己的内部常量**（如 `TaskRunMode`）
- ❌ 不能依赖 `application` 层的常量
- ✅ `application` 层负责转换：`ServiceType.WORKER` → `TaskRunMode.WORKER`

**命名规范**：
- 使用 `Enum` 类，继承 `str, Enum`
- 枚举值使用 `UPPER_SNAKE_CASE`：`WORKER`, `HIGH_PRIORITY`
- 枚举值字符串使用 `lower_snake_case`：`"worker"`, `"high_priority"`

## 异常处理规范

### 异常层次结构

```
FoundationError (common/exceptions/)
  ├── CoreException (domain/exceptions/)
  │   ├── ModelError
  │   │   └── VersionConflictError
  │   ├── ServiceException
  │   └── TransactionRequiredError
  │
  └── Infrastructure 层异常（infrastructure/*/exceptions.py）
      ├── DatabaseError
      ├── CacheError
      ├── StorageError
      ├── TaskError
      └── SchedulerError
```

### 异常定义规范

- **每个层定义自己的异常**：
  - `common/exceptions/` - `FoundationError`（最基础）
  - `domain/exceptions/` - `CoreException`, `ModelError`, `VersionConflictError`, `ServiceException`, `TransactionRequiredError`
  - `infrastructure/*/exceptions.py` - 各组件异常（继承 `FoundationError`）
- **异常命名**：使用完整单词，以 `Error` 结尾（`DatabaseError` ✅，`DbError` ❌）
- **异常继承**：所有异常都继承 `FoundationError`；Infrastructure 层异常直接继承 `FoundationError`（不继承 `CoreException`）

### 异常使用规范

- ✅ `domain` 层使用自己的异常
- ✅ `application` 层可以包装 `domain` 层异常
- ❌ `domain` 层不能使用 `application` 层异常（反向依赖）

## 配置管理规范

### 配置管理规范

- **Infrastructure 层配置**：每个组件有自己的 `settings.py`，使用 `pydantic-settings`，环境变量前缀：`DATABASE_*`, `CACHE_*`, `TASK_*`
- **Application 层配置**：继承 infrastructure 层配置作为适配层，提供统一配置接口
- **使用规范**：Infrastructure 层组件使用自己的 `settings.py`；Application 层使用 `application/config/settings.py`；Infrastructure 层不能直接使用 `application/config/settings.py`

## 约定大于配置规范

### 核心原则

**约定大于配置（Convention over Configuration）**：通过合理的约定和默认值，减少显式配置，提高开发效率。

**目标**：
- 减少样板代码
- 提供合理的默认值
- 遵循命名约定自动发现和配置
- 只在必要时才需要显式配置

### 1. 命名约定

#### 文件与目录命名

**约定**：
- 模块文件：`snake_case`（`user_service.py` ✅，`UserService.py` ❌）
- 包目录：`snake_case`（`user_management/` ✅，`UserManagement/` ❌）
- 类文件：通常与类名对应（`database_manager.py` → `DatabaseManager`）

**自动发现**：
- 组件自动发现：`infrastructure/*/manager.py` → `*Manager`
- 异常自动发现：`infrastructure/*/exceptions.py` → `*Error`
- 配置自动发现：`infrastructure/*/settings.py` → `*Settings`

#### 类与方法命名

**约定**：
- 类名：`PascalCase`（`DatabaseManager`）
- 方法名：`snake_case`（`get_user`）
- 私有方法：`_snake_case`（`_internal_method`）
- 常量：`UPPER_SNAKE_CASE`（`MAX_RETRIES`）

**自动映射**：
- Repository 方法约定：`get_by_{field}` → 自动查询字段
- Service 方法约定：`create_{entity}` → 自动创建实体

### 2. 目录结构约定

**约定结构**：
```
infrastructure/
  ├── {component}/          # 组件目录（如 database, cache）
  │   ├── __init__.py       # 导出主要接口
  │   ├── manager.py        # Manager 类（约定命名）
  │   ├── exceptions.py     # 异常类（约定命名）
  │   ├── settings.py       # 配置类（约定命名）
  │   └── constants.py      # 常量（可选）
```

**自动发现规则**：
- `infrastructure/{component}/manager.py` → `{Component}Manager`
- `infrastructure/{component}/exceptions.py` → `{Component}Error`
- `infrastructure/{component}/settings.py` → `{Component}Settings`

### 3. 默认值约定

#### 配置默认值

**约定**：配置项应提供合理的默认值，但关键配置项（如数据库连接、密钥等）应强制配置

**原则**：
- ✅ **提供默认值**：对于有意义的默认值（如端口、超时时间、重试次数等）
- ❌ **强制配置**：对于关键配置项（如数据库 URL、API 密钥、密码等），不应提供默认值，强制用户显式配置

**示例**：
```python
# ✅ 正确：提供有意义的默认值
class DatabaseSettings(BaseSettings):
    url: str = Field(description="数据库连接URL，必需配置")  # 关键配置，无默认值
    port: int = Field(default=5432, description="数据库端口")  # 有意义的默认值
    pool_size: int = Field(default=10, description="连接池大小")  # 有意义的默认值
    echo: bool = Field(default=False, description="是否打印SQL")  # 有意义的默认值

# ❌ 错误：关键配置提供无意义的默认值
class DatabaseSettings(BaseSettings):
    url: str = Field(default="postgresql://localhost:5432/app_db")  # 默认值无意义，用户必须配置
```

#### 行为默认值

**约定**：组件行为应有合理的默认值

**示例**：
```python
# ✅ 正确：默认行为
class CacheManager:
    async def get(self, key: str, default: Any = None) -> Any:
        # default=None 是合理的默认值
        pass

# ✅ 正确：默认配置
class TaskManager:
    async def initialize(
        self,
        run_mode: TaskRunMode = TaskRunMode.WORKER,  # 默认 Worker 模式
        max_retries: int = 3,  # 默认重试 3 次
    ) -> None:
        pass
```

### 4. 自动发现约定

#### 组件自动注册

**约定**：通过命名约定自动发现和注册组件

**示例**：
```python
# ✅ 正确：遵循命名约定，自动发现
# infrastructure/database/manager.py
class DatabaseManager:  # 命名约定：{Component}Manager
    pass

# application/app/components.py
# 框架自动发现 infrastructure/*/manager.py 并注册为组件
```

#### 路由自动发现

**约定**：通过文件结构自动发现路由（如果适用）

**示例**：
```
application/
  └── interfaces/
      └── api/
          ├── v1/
          │   ├── users.py      # 自动注册为 /api/v1/users
          │   └── orders.py     # 自动注册为 /api/v1/orders
```

### 5. 配置优先级约定

**约定优先级**（从高到低）：
1. **显式参数**：函数/方法参数
2. **环境变量**：环境变量
3. **配置文件**：配置文件中的值
4. **默认值**：代码中的默认值

**示例**：
```python
# 优先级：参数 > 环境变量 > 配置文件 > 默认值
class DatabaseSettings(BaseSettings):
    host: str = "localhost"  # 默认值（最低优先级）
    
    model_config = SettingsConfigDict(
        env_prefix="DATABASE_",  # 环境变量：DATABASE_HOST（中等优先级）
    )

# 使用
settings = DatabaseSettings(host="custom_host")  # 参数（最高优先级）
```

### 6. 约定覆盖规则

**原则**：约定应该可以被显式配置覆盖

**规则**：
- ✅ 提供默认约定
- ✅ 允许显式覆盖
- ❌ 不要强制约定（除非是核心架构要求）

**示例**：
```python
# ✅ 正确：约定可覆盖
class TaskManager:
    async def initialize(
        self,
        broker_url: str | None = None,  # 默认从环境变量读取
        queue_name: str = "default",    # 默认队列名
    ) -> None:
        # 如果提供了 broker_url，使用提供的值
        # 否则从环境变量读取
        # 否则使用默认值
        pass

# ❌ 错误：强制约定，无法覆盖
class TaskManager:
    async def initialize(self) -> None:
        # 硬编码，无法覆盖
        self._broker_url = "redis://localhost:6379/0"
```

### 7. 约定检查清单

**实施约定时检查**：
- [ ] 是否提供了合理的默认值？
- [ ] 命名是否遵循约定？
- [ ] 目录结构是否遵循约定？
- [ ] 约定是否可以被显式配置覆盖？
- [ ] 约定是否减少了样板代码？
- [ ] 约定是否清晰易懂？

### 8. 约定示例总结

| 场景 | 约定 | 显式配置 |
|------|------|----------|
| 数据库连接 | 默认 `localhost:5432` | `DATABASE_HOST`, `DATABASE_PORT` |
| 缓存键前缀 | 默认 `cache:` | `CACHE_KEY_PREFIX` |
| 任务队列名 | 默认 `default` | `queue_name` 参数 |
| 日志级别 | 默认 `INFO` | `LOG_LEVEL` 环境变量 |
| 组件名称 | 自动从目录名推断 | `Component.name` 属性 |

## 组件设计规范

### Component 基类

所有功能单元（中间件、数据库、缓存、任务等）都统一为 `Component`：

```python
class Component(ABC):
    name: str  # 组件名称
    enabled: bool = True  # 是否启用
    depends_on: list[str] = []  # 依赖的组件名称
    
    def can_enable(self, config: BaseConfig) -> bool:
        """判断是否启用（基于配置）。"""
        return self.enabled
    
    @abstractmethod
    async def setup(self, app: FoundationApp, config: BaseConfig) -> None:
        """初始化组件。"""
        pass
    
    @abstractmethod
    async def teardown(self, app: FoundationApp) -> None:
        """清理组件。"""
        pass
```

### 组件设计原则

1. **抽象统一**：所有功能单元都是 `Component`，无特殊处理
2. **可扩展**：子类可以覆盖 `items` 列表，添加/移除/替换组件
3. **依赖声明**：通过 `depends_on` 声明依赖，框架自动拓扑排序
4. **配置驱动**：通过 `can_enable()` 基于配置判断是否启用

### 组件转换规范

当 infrastructure 层组件需要 application 层配置时，应在 `Component.setup()` 中进行转换，将应用配置转换为组件需要的参数。

## 代码复用与动态行为设计

本规范指导团队在处理代码复用（Mixin/组合）和动态行为（策略/函数式）时，如何做出正确的架构选择。

### I. 核心设计原则

#### 1. 组合优于继承（但 Mixin 是例外）

**原则描述**：优先使用对象组合 (has-a 关系) 而非类继承。**但 Mixin 是合理的例外**，用于提供无状态的工具方法。

**目的**：降低耦合，依赖显式化，同时保持代码简洁。

**示例**：
```python
# ✅ 正确：使用组合（适用于有状态或复杂逻辑）
class UserService:
    def __init__(self, logger: LoggerService):
        self._logger = logger

# ✅ 正确：使用 Mixin（适用于简单、无状态的工具方法）
class UserModel(BaseModel, TimestampMixin, UUIDMixin):
    # Mixin 提供 created_at, updated_at, id 等字段
    pass

# ❌ 错误：使用 Mixin 引入复杂逻辑或隐式依赖
class UserService(LoggingMixin):  # 隐式依赖全局 logger，难以测试
    pass
```

#### 2. 依赖注入 (DI)

**原则描述**：核心类不应自己实例化依赖，应通过构造函数或 Setter 注入。

**目的**：提高可测试性，支持 Mock。

**示例**：
```python
# ✅ 正确：通过构造函数注入
class OrderService:
    def __init__(self, payment_strategy: PaymentStrategy, logger: LoggerService):
        self._payment_strategy = payment_strategy
        self._logger = logger

# ❌ 错误：在类内部实例化依赖
class OrderService:
    def __init__(self):
        self._payment_strategy = AlipayStrategy()  # 硬编码依赖
```

#### 3. 开闭原则

**原则描述**：模块应对于扩展开放，对于修改关闭。

**目的**：提高系统稳定性。

**示例**：
```python
# ✅ 正确：策略模式扩展
class PaymentStrategy(ABC):
    @abstractmethod
    def process_payment(self, order: Order) -> None: pass

# ❌ 错误：if/else 判断
def process_payment(self, order: Order, payment_type: str) -> None:
    if payment_type == "alipay": ...
    elif payment_type == "wechat": ...  # 添加新方式需修改
```

### II. 代码复用策略：能力管理

#### 1. 工具方法/特质 - 首选：Mixin/Trait（适用于简单场景）

**场景**：引入无状态的、简单的工具方法或字段定义。

**实施准则**：
- ✅ **适用于**：简单的属性定义、工具方法、查询构建器方法
- ✅ **优点**：代码简洁、易于组合、无状态
- ❌ **严禁**：在 Mixin 中引入核心业务逻辑
- ❌ **严禁**：在 Mixin 中隐式依赖全局对象（如全局 logger、全局 session）
- ❌ **严禁**：在 Mixin 中引入有状态的复杂逻辑

**示例**：
```python
# ✅ 正确：Mixin 提供简单的字段定义
class TimestampMixin:
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True))

# ✅ 正确：Mixin 提供简单的工具方法
class AuditableStateMixin:
    deleted_at: Mapped[int] = mapped_column(BigInteger, default=0)
    
    @property
    def is_deleted(self) -> bool:
        return self.deleted_at > 0
    
    @classmethod
    def not_deleted(cls) -> Select:
        """简单的查询构建器方法。"""
        return select(cls).where(cls.deleted_at == 0)

# ❌ 错误：Mixin 包含复杂逻辑或隐式依赖
class DatabaseMixin:
    def save(self) -> None:  # ❌ 数据库操作（应该用 Repository）
        session.add(self)
    
    def log(self, message: str) -> None:  # ❌ 隐式依赖全局 logger
        logger.info(message)
```

#### 2. 通用能力/复用 - 次选：组合 (Composition)（适用于复杂场景）

**场景**：功能需封装为独立的 Service 或 Component，包含有状态或复杂逻辑。

**实施准则**：
- 适用于有状态或复杂逻辑
- 通过构造函数或 Setter 注入
- 保持依赖显式化

**示例**：
```python
# ✅ 正确：组合（适用于有状态或复杂逻辑）
class UserService:
    def __init__(self, logger: LoggerService, cache: CacheService):
        self._logger = logger  # 显式依赖
        self._cache = cache    # 显式依赖

# ✅ 正确：使用函数式工具函数（替代隐式依赖的 Mixin）
class UserService:
    def do_something(self):
        log = get_class_logger(self)  # 显式调用，无隐式依赖
        log.info("执行操作")
```

### III. 动态行为管理：运行时变化

#### 1. 复杂算法切换 - 策略模式 (Strategy)

**场景**：用于封装易变的、复杂的业务规则。

**实施准则**：
- 所有策略必须实现同一 Interface
- 策略必须通过 DI 容器或构造函数注入宿主类
- 严禁在宿主类内部使用 `new ConcreteStrategy()`

**示例**：
```python
# ✅ 正确：策略模式 + DI
class OrderService:
    def __init__(self, payment_strategy: PaymentStrategy):
        self._payment_strategy = payment_strategy

# ❌ 错误：类内部实例化
class OrderService:
    async def checkout(self, order: Order, payment_type: str):
        if payment_type == "alipay":
            strategy = AlipayStrategy()  # ❌ 硬编码依赖
```

#### 2. 简单算法变化 - 函数式编程 (Functional)

**场景**：如果算法无状态且只有一个执行方法。

**实施准则**：
- 优先传递 Lambda 表达式/函数（Hook/Callback）
- 避免创建不必要的策略类
- 适用于简单的计算、转换、过滤等操作

**示例**：
```python
# ✅ 正确：函数式
def calculate_discount(price: float, discount_func: Callable[[float], float]) -> float:
    return discount_func(price)

discounted_price = calculate_discount(100.0, lambda p: p * 0.9)

# ❌ 错误：为简单算法创建策略类（过度设计）
class DiscountStrategy(ABC): ...
```

### IV. 横切关注点处理（功能增强）

#### 装饰器模式 (Decorator) / AOP

**场景**：用于增加缓存、性能监控、鉴权、事务等功能。

**实施要求**：
- 增强功能必须通过包裹原始对象实现
- 严禁直接修改策略类或核心类的代码
- 保持核心逻辑的纯净性

**示例**：
```python
# ✅ 正确：装饰器模式
class CachedPaymentStrategy(PaymentStrategy):
    def __init__(self, strategy: PaymentStrategy, cache: CacheService):
        self._strategy = strategy
        self._cache = cache

# ❌ 错误：直接修改策略类代码
class AlipayStrategy(PaymentStrategy):
    async def process_payment(self, order: Order):
        # ❌ 在策略类中添加缓存逻辑，污染核心逻辑
        cached_result = await cache.get(cache_key)
        ...
```

### V. 快速决策参考表

| 你想做什么？ | 应该使用什么工具？ | 禁用/避免什么？ |
|------------|------------------|----------------|
| 给模型增加时间戳字段 | Mixin (TimestampMixin) | 在每个模型中重复定义 |
| 给模型增加软删除功能 | Mixin (AuditableStateMixin) | 在每个模型中重复实现 |
| 给类增加日志功能（有状态/复杂） | 组合 (LoggerService) 或函数式工具 | Mixin 隐式依赖全局 logger |
| 支持多种支付方式 | 策略模式 + DI | 大量的 if/else 判断 |
| 给现有策略增加缓存 | 装饰器模式 | 直接修改策略类代码 |
| 计算订单时切换折扣公式 | 函数式 (Lambda) | 为每个折扣公式创建策略类 |
| 复用包含数据库操作的逻辑 | 组合 (Repository/Service) | Mixin 封装数据库操作 |

### VI. 高内聚与低耦合

- **高内聚**：相关的功能应该组织在一起
- **低耦合**：模块之间的依赖应该最小化，通过接口依赖而非具体实现

## 依赖选择规范

### 核心原则

**优先使用最先进但已被验证过的开源包**。

### 选择标准

1. **先进性**：
   - 支持最新的 Python 版本特性（优先 Python 3.13+）
   - 采用现代设计模式和最佳实践
   - 活跃维护，定期发布更新

2. **验证性**：
   - 在大型项目中得到验证
   - 有良好的测试覆盖率
   - 社区活跃，问题响应及时
   - 文档完善

3. **技术栈一致性**：
   - 与项目技术栈兼容（异步优先、类型提示完善）
   - 遵循相同的设计理念（如组合优于继承）

### 选择示例

**✅ 推荐**：
- `ruff` - 现代、快速的代码检查工具（替代 black + pylint）
- `dramatiq` - 现代异步任务队列（替代 Celery）
- `kombu` - 灵活的消息传输层（支持多种后端）
- `pydantic v2` - 现代数据验证（类型提示完善）
- `sqlalchemy 2.0+` - 现代 ORM（异步支持、类型提示）

**❌ 避免**：
- 已停止维护的包
- 设计过时的包（如 Celery，异步性能差、内存泄漏）
- 功能重复但不够先进的包（如 RQ，功能简单、同步设计）

### 评估清单

选择新依赖时检查：
- [ ] 是否支持 Python 3.13+？
- [ ] 是否有完善的类型提示？
- [ ] 是否采用异步设计（如适用）？
- [ ] 是否在大型项目中得到验证？
- [ ] 是否活跃维护（最近 3 个月内有更新）？
- [ ] 是否有完善的文档？
- [ ] 是否与项目设计理念一致？

## 命名规范

- **模块和包**：小写字母和下划线（`database` ✅，`db` ❌）
- **类**：`PascalCase`（`DatabaseManager`）；异常类以 `Error` 结尾（`DatabaseError` ✅，`DbError` ❌）
- **常量**：枚举类 `PascalCase`（`ServiceType`）；枚举值 `UPPER_SNAKE_CASE`（`WORKER`）；枚举值字符串 `lower_snake_case`（`"worker"`）
- **函数和变量**：`snake_case`（`setup_logging`）；布尔值使用 `is_` 或 `has_` 前缀（`is_initialized`）

## 导入规范

**导入顺序**：
1. 标准库
2. 第三方库
3. 本地模块（按层次顺序：common → domain → infrastructure → application）

**引用位置**：
- **所有引用应放在代码文件的最上方**，在文档字符串之后、实际代码之前
- 非必要情况下，禁止在函数或类内部进行导入
- 特殊情况允许在函数内部导入：解决循环依赖、条件导入、延迟加载重型模块

## 类型提示规范

- 使用 Python 3.13 语法：`list[str]` ✅，`List[str]` ❌；`str | None` ✅，`Optional[str]` ❌
- 所有公共函数必须有类型提示
- 使用 `from __future__ import annotations` 启用延迟求值
- 复杂类型使用 `TypeVar` 或 `Generic`

## HTTP 相关代码规范

### 1. HTTP 中间件位置

所有 HTTP 相关的代码（中间件、装饰器）应该在 `application/middleware/` 目录：

```
application/
  └── middleware/
      └── logging.py      # RequestLoggingMiddleware, log_request
```

### 2. Common 层禁止 HTTP 依赖

`common` 层不能包含任何 HTTP 框架依赖：

- ❌ `common` 层不能有 HTTP 依赖（FastAPI、Starlette）
- ✅ HTTP 相关代码应在 `application/middleware/` 目录

## 测试与代码质量规范

- **测试**：测试文件应在 `testing/` 目录；`testing/` 可以依赖所有层（用于测试）
- **代码质量**：使用 `ruff` 进行代码检查和格式化；所有公共类、函数必须有中文文档字符串（包含参数说明、返回值说明、使用示例）

## 向后兼容性政策

**核心原则**：**禁止向后兼容**，Foundation Kit 不提供任何向后兼容功能。

**政策**：
- ❌ 不保留旧 API、不提供 `deprecated` 警告、不保留 `_old`、`_legacy` 等后缀
- ❌ 不兼容旧字段、不兼容旧配置、不提供配置迁移工具
- ✅ 直接删除旧代码，在变更日志中明确说明破坏性变更，通过版本号明确标识

**示例**：
```python
# ❌ 错误：保留向后兼容代码
elif hasattr(self._model_class, "yn"):  # 兼容旧代码
    query = query.where(self._model_class.yn.is_(True))

# ✅ 正确：直接使用新实现
if hasattr(self._model_class, "deleted_at"):
    query = query.where(self._model_class.deleted_at.is_(None))
```

## 总结

### 核心原则

1. **分层清晰**：common → domain → infrastructure → application
2. **依赖单向**：只能向下依赖，不能向上依赖
3. **配置转换**：application 层负责将应用配置转换为组件参数
4. **组件独立**：infrastructure 层组件使用自己的内部常量和配置
5. **HTTP 隔离**：HTTP 相关代码只在 application 层
6. **约定大于配置**：通过合理的约定和默认值减少显式配置

### 检查清单

写完后检查：

**禁止项**：
- [ ] **是否包含任何向后兼容代码？**（禁止）
- [ ] **是否包含 `deprecated`、`legacy`、`兼容` 等关键词？**（禁止）

**架构与依赖**：
- [ ] 是否遵循依赖关系规则（application → domain → infrastructure → common）？
- [ ] 常量是否放在正确的层？
- [ ] 异常是否继承 `FoundationError`？
- [ ] HTTP 相关代码是否在 `application/middleware/`？

**约定大于配置**：
- [ ] 是否提供了合理的默认值？
- [ ] 命名是否遵循约定（文件、类、方法）？
- [ ] 目录结构是否遵循约定？
- [ ] 约定是否可以被显式配置覆盖？

**代码质量**：
- [ ] 是否使用 Python 3.13 类型提示语法？
- [ ] 是否有完整的文档字符串？
- [ ] 是否通过 `ruff` 检查？
- [ ] 是否通过 `ruff` 检查？

**代码复用与设计**：
- [ ] 简单工具方法是否使用 Mixin（无状态、无隐式依赖）？
- [ ] 复杂逻辑是否使用组合（有状态、显式依赖注入）？
- [ ] Mixin 是否仅包含简单的工具方法，无隐式依赖？
- [ ] 依赖是否通过构造函数或 Setter 注入？
- [ ] 复杂算法是否使用策略模式？
- [ ] 简单算法是否使用函数式编程？
- [ ] 功能增强是否使用装饰器模式？
